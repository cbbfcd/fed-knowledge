# GC算法

早期的浏览器（其实我想吐槽 IE ）采用的是一种叫做[引用计数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)的算法，原理就是如果一块内存没有指针指向它，那么它就可以被回收了。但是，诸如循环引用这种情况，它就无能为力了。

```text
function Foo(){    
    let a = {};    
    let b = {};    
    a.name = b;    
    b.name = a;    
    return 'cycle reference!'
}
Foo();
```

`Foo` 函数执行完毕了，`a，b` 其实都不需要了，但是因为循环引用的存在，引用计数算法就会认为它们不应该回收，造成了内存的泄露。

现代浏览器基本都使用了各种版本的标记[清除算法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)​

> 这个算法假定设置一个叫做根（root）的对象（在 JavaScript 里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

意思很简单，就是从根出发，不能访问到的对象给个标记，等会儿就可以释放它了。这种算法可以解决上面的循环引用的问题。

GC 在执行的时候会阻塞其他的进程，至少在 50 ms 以上（这个数据可能是瞎掰的），这在普通的web项目上还好，在游戏中或者是动画连贯要求高的项目就不能忍了 。

针对上面的问题主要有 2 种优化的方式：

1. 分代 GC : 就是 Java 中的那一套，分成 `young` 区和 `tenured` 区，多去回收前者区域的，减少每次需要遍历的数量，从而减少耗时。
2. 增量 GC : 类比增量更新技术，就是一次整一点，下一次接着整。

对于浏览器环境，比如 Chrome 中，V8 中的所有的 JavaScript 对象都是通过堆来进行分配的。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8的限制为止。

它限制了堆内存在1.4G（64位），它为什么要做这个限制的原因也是因为 GC 在更大的堆内存下需要更多的耗时，而这样的阻塞是不能容忍的。

